# Chatper3 Two Steps in Scala
3장에서는 2장에서 시작한 스칼라 소개에 이어, 몇 가지 고급 주제를 더 소개할 것이다. 이번 장을 마치고 나면 스칼라로 쓸모 있는 스크립트를 작성할 수 있을 정도로 충분한 지식을 쌓을 수 있으리라 확신한다. 2장과 마찬가지로 3장의 예제도 실제로 실행해보기를 바란다. 스칼라에 대해 감을 잡는 가장 좋은 방법은 실제로 써보는 것이다.

## 7단계: 배열에 타입 파라미터를 지정해보자 
스칼라에서는 `new`를 사용해 객체를 인스턴스화할 수 있다. 즉, 클래스의 인스턴스를 만들 수 있다. 스칼라에서 객체를 인스턴스화할 때, 값과 타입을 파라미터로 넘길 수 있다. **파라미터화**`parameterization`라는 말은 인스턴스를 생성할 때 그 인스턴스를 '설정`configure`'한는 뜻이다. 인스턴스를 값으로 파리미터화하려면 괄호 안에 객체들을 넣어서 생성자에게 넘긴다. 예를 들어 다음 스칼라 코드는 새로운 `java.math.BigInteger`인스턴스를 만들고 값 `"12345"`로 그 인스턴스를 파라미터화한다.

```scala
val big = new java.math.BigInteger("12345")
```
인스턴스를 타입으로 파라미터화할 때는 하나이상의 타입을 각괄호([])사이에 지정한다. 리스트 3.1에 예제가 있다. 이 예제에서 `greetStrings`는 `Array[String]`('array of string'이라는 말의 순서와 타입의 순서가 같다)이라는 타입의 값이다.
이 배열을 `3`이라는 값으로 파라미터화함으로써 길이를 초기화한다. 

#####리스트3.1 배열을 타입으로 파라미터화하기

```scala
val greetStrings = new Array[String](3)
greetStrings(0) = "Hello"
greetStrings(1) = ", "
greetStrings(2) = "world!\n"
for (i <- 0 to 2)
	print(greetStrings(i))
```
좀 더 명시적으로 코드를 만들면 다음과 같이 `greetStrings`의 타입을 지정할 수도 있다.

```scala
val greetStrings: Array[String] = new Array[String](3)
```
이 문장은 타입 파라미터화 부분(각괄호 사이에 타입을 넣은 것)은 인스턴스 타입의 일부지만, 값을 파라미터화한 것(괄호 안에 값 3을 넣응 부분)은 그렇지 않다는 사실을 보여준다. 즉 `greetStrings`의 타입은 `Array[String]`이지 `Array[String](3)`이 아니다.  
다음 세 줄의 코드는 스칼라의 `val`의 의미와 관련해 중요한 개념을 보여준다. 어떤 변수를 `val`로 지정하면 그 변수를 재할당할 수 없다. 하지만 그 변수가 나타내는 객체는 잠재적으로 여전히 변경 가능하다. 이 경우, `greetStrings`에 다른 변수를 넣을 수는 없다. 따라서 `greetStrings`는 항상 초기화 시 설정한 것과 같은 `Array[String]`타입의 배열을 가리킨다. 하지만 `Array[String]`의 원소는 언제나 변경할 수 있다. 따라서 배열 자체는 변경 가능`mutable`하다.  
리스트 3.1의 마지막 두 줄은 각 `greetStrings`의 배열의 원소를 하나하나 출력하는 `for`표현식이다.

```scala
for (i <- 0 to 2)
	print(greetStrings(i))
```
이 코드의 첫 줄은 '메소드가 파라미터를 하나만 요구하는 경우, 그 메소드를 점(.)과 괄호 없이 호출할 수 있다' 라는 스칼라의 또 다른 일반 규칙을 보여준다. 이 예에 있는 `to`는 실제로는 `Int`인자를 하나만 받는 메소드다. `0 to 2`는 `(0).to(2)`라는 메소드 호출로 바뀐다. 호출 대상 객체를 명시적으로 지정할 때만 이런 문법을 사용할 수 있다는 사실에 유의하라. 그래서 `'print 10'`이라고 쓸 수는 없지만, `'Console println 10'`이라고는 쓸 수 있다.  
스칼라는 기술적으로는 연산자 오버로드를 제공하지 않는다. 스칼라에는 실제 전통적인 의미의 연산자가 없기 때문이다. 대신에 +,-,*,/ 등의 문자를 메소드 이름으로 사용할 수 있다. 따라서 1단계에서 `1 + 2`를 스칼라 인터프리터에 입력했을 때 실제로 일어난 일은, `1`이라는 `Int`객체에 있는 `+`라는 이름의 메소드를 `2`를 인자로 호출한 것이다.  
이 예가 보여주는 또 다른 중요한 개념은 스칼라에서 왜 배열을 괄호로 사용해 접근할 수 있는가이다. 스칼라는 자바보다 예외적인 경우가 적다. 스칼라 배열도 여타 객체와 마찬가지로 평범한 클래스의 인스턴스다. 변수 뒤에 하나 이상의 값을 괄호로 둘러싸서 호출하면 스칼라는 그 코드를 변수에 대해 `apply`라는 메소드를 호출하는 것으로 바꾼다. 따라서 `greetStrings(i)`는 `greetStrings.apply(i)`로 바뀐다. 따라서 스칼라에서 배열의 원소에 접그나흔 것은 일반적인 메소드 호출과 같다. 이런 원칙은 배열에만 국한된 것이 아니다. 어떤 종류의 객체이든 괄호 안에 인자를 넣어서 호출하면 `apply`메소드를 호출하는 것과 같다. 물론, 해당 객체 안에 `apply`메소드가 있어야만 코드를 제대로 컴파일할 수 있다. 따라서 배열 원소 접근은 특별한 형태가 아니고 일반적인 규칙에 따른 것이다.

```scala
  1 + 2

(1). + (2)

1: 1이라는 값의 Int객체다.
+: 1에 대해 '+'라는 이름의 메소드를 호출한다.
2: Int객체 2를 '+'메소드에 전달한다.
```
마찬가지로, 어떤 변수 뒤에 괄호로 둘러싼 인자들이 있는 표현식에 할당을 하면 컴파일러는 괄호 안에 있는 인자와 등호 오른쪽의 값을 모두 인자호 넣어서  `update`메소드를 호출한다. 예를 들어 스칼라는 다음 식을

```scala
greetStrings(0) = "Hello"
```
다음과 같이 변환한다.

```
greetStrings.update(0, "Hello")
```