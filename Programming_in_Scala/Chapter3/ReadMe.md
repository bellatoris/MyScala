# Chatper3 Two Steps in Scala
3장에서는 2장에서 시작한 스칼라 소개에 이어, 몇 가지 고급 주제를 더 소개할 것이다. 이번 장을 마치고 나면 스칼라로 쓸모 있는 스크립트를 작성할 수 있을 정도로 충분한 지식을 쌓을 수 있으리라 확신한다. 2장과 마찬가지로 3장의 예제도 실제로 실행해보기를 바란다. 스칼라에 대해 감을 잡는 가장 좋은 방법은 실제로 써보는 것이다.

## 7단계: 배열에 타입 파라미터를 지정해보자 
스칼라에서는 `new`를 사용해 객체를 인스턴스화할 수 있다. 즉, 클래스의 인스턴스를 만들 수 있다. 스칼라에서 객체를 인스턴스화할 때, 값과 타입을 파라미터로 넘길 수 있다. **파라미터화**`parameterization`라는 말은 인스턴스를 생성할 때 그 인스턴스를 '설정`configure`'한는 뜻이다. 인스턴스를 값으로 파리미터화하려면 괄호 안에 객체들을 넣어서 생성자에게 넘긴다. 예를 들어 다음 스칼라 코드는 새로운 `java.math.BigInteger`인스턴스를 만들고 값 `"12345"`로 그 인스턴스를 파라미터화한다.

```scala
val big = new java.math.BigInteger("12345")
```
인스턴스를 타입으로 파라미터화할 때는 하나이상의 타입을 각괄호([])사이에 지정한다. 리스트 3.1에 예제가 있다. 이 예제에서 `greetStrings`는 `Array[String]`('array of string'이라는 말의 순서와 타입의 순서가 같다)이라는 타입의 값이다.
이 배열을 `3`이라는 값으로 파라미터화함으로써 길이를 초기화한다. 

#####리스트3.1 배열을 타입으로 파라미터화하기

```scala
val greetStrings = new Array[String](3)
greetStrings(0) = "Hello"
greetStrings(1) = ", "
greetStrings(2) = "world!\n"
for (i <- 0 to 2)
	print(greetStrings(i))
```
좀 더 명시적으로 코드를 만들면 다음과 같이 `greetStrings`의 타입을 지정할 수도 있다.

```scala
val greetStrings: Array[String] = new Array[String](3)
```
이 문장은 타입 파라미터화 부분(각괄호 사이에 타입을 넣은 것)은 인스턴스 타입의 일부지만, 값을 파라미터화한 것(괄호 안에 값 3을 넣응 부분)은 그렇지 않다는 사실을 보여준다. 즉 `greetStrings`의 타입은 `Array[String]`이지 `Array[String](3)`이 아니다.  
다음 세 줄의 코드는 스칼라의 `val`의 의미와 관련해 중요한 개념을 보여준다. 어떤 변수를 `val`로 지정하면 그 변수를 재할당할 수 없다. 하지만 그 변수가 나타내는 객체는 잠재적으로 여전히 변경 가능하다. 이 경우, `greetStrings`에 다른 변수를 넣을 수는 없다. 따라서 `greetStrings`는 항상 초기화 시 설정한 것과 같은 `Array[String]`타입의 배열을 가리킨다. 하지만 `Array[String]`의 원소는 언제나 변경할 수 있다. 따라서 배열 자체는 변경 가능`mutable`하다.  
리스트 3.1의 마지막 두 줄은 각 `greetStrings`의 배열의 원소를 하나하나 출력하는 `for`표현식이다.

```scala
for (i <- 0 to 2)
	print(greetStrings(i))
```
이 코드의 첫 줄은 '메소드가 파라미터를 하나만 요구하는 경우, 그 메소드를 점(.)과 괄호 없이 호출할 수 있다' 라는 스칼라의 또 다른 일반 규칙을 보여준다. 이 예에 있는 `to`는 실제로는 `Int`인자를 하나만 받는 메소드다. `0 to 2`는 `(0).to(2)`라는 메소드 호출로 바뀐다. 호출 대상 객체를 명시적으로 지정할 때만 이런 문법을 사용할 수 있다는 사실에 유의하라. 그래서 `'print 10'`이라고 쓸 수는 없지만, `'Console println 10'`이라고는 쓸 수 있다.  
스칼라는 기술적으로는 연산자 오버로드를 제공하지 않는다. 스칼라에는 실제 전통적인 의미의 연산자가 없기 때문이다. 대신에 +,-,*,/ 등의 문자를 메소드 이름으로 사용할 수 있다. 따라서 1단계에서 `1 + 2`를 스칼라 인터프리터에 입력했을 때 실제로 일어난 일은, `1`이라는 `Int`객체에 있는 `+`라는 이름의 메소드를 `2`를 인자로 호출한 것이다.  
이 예가 보여주는 또 다른 중요한 개념은 스칼라에서 왜 배열을 괄호로 사용해 접근할 수 있는가이다. 스칼라는 자바보다 예외적인 경우가 적다. 스칼라 배열도 여타 객체와 마찬가지로 평범한 클래스의 인스턴스다. 변수 뒤에 하나 이상의 값을 괄호로 둘러싸서 호출하면 스칼라는 그 코드를 변수에 대해 `apply`라는 메소드를 호출하는 것으로 바꾼다. 따라서 `greetStrings(i)`는 `greetStrings.apply(i)`로 바뀐다. 따라서 스칼라에서 배열의 원소에 접그나흔 것은 일반적인 메소드 호출과 같다. 이런 원칙은 배열에만 국한된 것이 아니다. 어떤 종류의 객체이든 괄호 안에 인자를 넣어서 호출하면 `apply`메소드를 호출하는 것과 같다. 물론, 해당 객체 안에 `apply`메소드가 있어야만 코드를 제대로 컴파일할 수 있다. 따라서 배열 원소 접근은 특별한 형태가 아니고 일반적인 규칙에 따른 것이다.

```scala
  1 + 2

(1). + (2)

1: 1이라는 값의 Int객체다.
+: 1에 대해 '+'라는 이름의 메소드를 호출한다.
2: Int객체 2를 '+'메소드에 전달한다.
```
마찬가지로, 어떤 변수 뒤에 괄호로 둘러싼 인자들이 있는 표현식에 할당을 하면 컴파일러는 괄호 안에 있는 인자와 등호 오른쪽의 값을 모두 인자호 넣어서  `update`메소드를 호출한다. 예를 들어 스칼라는 다음 식을

```scala
greetStrings(0) = "Hello"
```
다음과 같이 변환한다.

```
greetStrings.update(0, "Hello")
```
## 8단계: 리스트를 사용해보자

함수형 프로그래밍의 가장 큰 착안점 하나는 메소드에 **부수 효과가 없어**야 한다는 것이다. 메소드의 유일한 동작은 계산을 해서 값을 반환하는 것뿐이어야 한다. 이런 함수적인 철학을 객체의 세계에 적용하면, 객체를 변경 불가능하게 만든다는 뜻이다. 리스트는 같은 타입의 객체로 이루어져 있으며 변경 불가능하다. 

```scala
val oneTwoThree = List(1, 2, 3)
```

리스트에서 가장 사용하는 연산자는 `::` 일 것이다. 이 메소드를 '콘즈cons'라 부른다. 콘즈는 새 원소를 기존의 리스트의 맨 앞에 추가한 **새 리스트**를 반환한다.

> `1 :: List`라는 표현식에서 `::`는 오른쪽에 있는 피연산자인 리스트의 메소드이다. 메소드 이름이 콜론(`:`)으로 끝나면, 연산자 방식으로 사용 시 오른쪽 피연산자에 대해 호출을 한다. 따라서 `1 :: List` 라는 표현식을 `List`를 호출 대상 객체로, `1`을 인자로 받는 메소드 호출인 `List.::(1)`로 해석한다.

## 9단계 튜플을 사용해보자.
**튜플tuple**은 리스트와 마찬가지로 변경 불가능하지만, 튜플에는 가긱 다른 타입의 운소를 넣을 수 있다. 튜플은 예를 들어 메소드에서 여러 객체를 반환해야 하는 경우 아주 유용하다. 튜플의 각 원소는 점(`.`)과 밑줄(`_`) 다음에 `1`부터 시작하는 인덱스를 넣으면 접근할 수 있다. 

```scala
val pair = (99, "Luftballons")
println(pair._1)
println(pair._2)
```

> 튜플 각각의 원소가 타입이 다 다르기 때문에 `apply`메소드를 사용해서 `pair(0)`과 같이 반환하는 것은 불가능하다. `_N` 인덱스가 0이 아니라 1부터 시작하는 이유는 하스켈이나 ML같이 정적인 타입을 사용하는 함수형 언어에서 전통적으로 튜플의 인덱스르 1부터 세어왔기 때문이다.

## 11단계: 함수형 스타일을 인식하는 법을 배우자.
첫 단계는 코드상에서 함수형과 명령형 스타일의 차이를 인지하는 것이다. 한 가지 숨길 수 없는 지표는 코드에 `var`가 있다면 명령형 스타일일 것이란 점이다. 코드에 전혀 `var`가 없다면 (즉, 오직 `val`만 코드에 있다면) 그 코드는 아마도 함수형 스타일일 것이다. 따라서 함수형으로 한 걸음 더 나아가는 방법은 `var`를 사용하지 않고 프로그램하려 노력하는 것이다. 예제를 살펴보자.

```scala
def printArgs(args: Array[String]): Unit = {
	var i = 0
	while (i < args.length) {
		println(args(i)
	}
}
```
이 코드를 `var`를 없애고 더 함수적으로 만들 수 있다.

```scala
def printArgs(args: Array[String]): Unit = {
	for (arg <- args)
		println(arg)
}
```
또는 다음과 같이 할 수도 있다.

```scala
def printArgs(args:Array[String]): Unit = {
	args.foreach(println)
}
```
이 코드는 변수를 덜 사용해서 프로그래밍할 때의 장점을 보여준다. 리팩토링한 (더 함수형이) 코드는 더 명확하고 간결하며, 원래의 (더 명령형인) 코드에 비해 오류 가능성이 낮다.

하지만 더 멀리 나아갈 수도 있다. 리팩토링한 `printArgs` 메소드는 완전히 함수형 코드는 아니다. 내부에 **부수 효과**가 있기 때문이다. 여기서는 표준 출력 스트림에 글자를 찍는 것이 바로 부수 효과다. 부수 효과가 있는 함수를 나타내는 분명한 지표는 결과 티입이 `Unit`인가 하는 점이다. 어떤 함수가 관심의 대상이 될 만한 값을 반환 하지 않는다면 (바로 그것이 `Unit`라는 결과 타입이 의미하는 바인데) 그런 함수가 주변 세계에 영향을 끼칠 수 있는 유일한 방법은 어떤 형태로든 부수 효과를 통하는 것일 수밖에 없다. 더 함수적인 접근 방식은 인자로 받는 것을 출력을 위해 형식화 하는 메소드를 정의하고, 그렇게 만들어낸 문자열을 반화하는 것이다.

```scala
def formatArgs(args: Array[String]) = args.mkString("\n")
```
이제 정말 함수적인 코드로 바뀌었다. `var`나 부수 효과를 찾아볼 수 없다. 그러나 모든 유용한 프로그램에는 어떤 형태로든 부수 효과가 들어가기 마련이다. 부수 효과 없이 외부 세계에 값을 전달할 방법이 없기 때문이다. 부수 효과가 없는 메소드를 더 우선시하면, 부수 효과가 있는 코드를 최소로 사용하면서 프로그래밍하는 습관을 들일 수 있다. 이런 접근 방법의 이점 중 하나는 프로그램을 테스트하기가 더 쉽다는 것이다. 예를 들어 `printArgs`를 테스트하려면 `println`을 수정해서 자신에게 인자로 들어온 출력을 원하는 값과 비교하도록 바꿔야 한다. 반면, `formatArgs` 함수는 그냥 값을 원하는 문자열과 비교하면 테스트가 가능하다.

```scala
val res = formatArgs(Array("zero", "one", "two"))
assert(res == "zero\none\ntwo")
```
그렇긴 하지만, `var`나 부수 효과가 근본적으로 나쁜 것이 아님을 기억하라. 스칼라는 모든 프로그램을 함수형 스타일로 강제로 작성하게 만든느 순수 함수형 언어가 아니다. 스칼라는 명령형과 함수형을 혼합한 언어다. 풀어야 할 문제에 따라 어떤 경우에는 명령형 스타일이 더 적합하고, 그런 경우 명령형 방법을 사용하는 것을 주저하지 말아야 한다. 

> 스칼라 프로그래머의 균형 잡힌 태도
> `val`, 변경 불가능한 객체, 부수 효과가 없는 메소드를 더 많이 사용하라. 먼저 그런 접근 방법을 시도해보라. `var`나 변경 가능 객체나 부수 효과가 있는 메소드를 사용해야 할 구체적인 필요성이 있고 그런 이유를 정당화할 수 있는 경우에만 `var`, 변경 가능성, 부수 효과를 사용하라.