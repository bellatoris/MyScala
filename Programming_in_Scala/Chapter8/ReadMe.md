# Cahpter8 함수와 클로져

함수 리터럴은 클래스로 컴파일하는데, 해당 클래스를 실행 시점에 인스턴스화 하면 **함수 값**이 된다. 함수 리터럴과 값의 차이는 함수 리터럴은 소스 코드에 존재하는 반면, 함수 값은 실행 시점에 객체로 존재한다는 점에 있다. 이 차이는 소스 코드에서 존재하는 클래스와 실행 시점에 존재하는 객체의 차이와도 유사하다.

## 위치 표시자 문법
```scala
val f = (_: Int) + (_: Int)
```

`_ + _`을 해석하면 인자를 2개 받는 함수의 리터럴임에 유의하자. 축약 형태로 표현할 수 있으려면, 각 인자가 함수에 최대 한 번씩만 등장해야만 한다. 여러 밑줄은 하나의 인자를 반복해서 사용하는 게 아니라, 여러 개의 인자를 의미한다. 첫 밑줄은 첫 번째 인자를, 두 번째 밑줄은 두 번째 인자를 나타낸다. 세 번째 이후의 밑줄들도 마찬가지로 세 번째 이후 각각의 인자를 의미한다.

## 부분 적용 함수
전체 파라미터 목록을 `_`로 바꿀 수 있다. 

```scala
def sum(a: Int, b: Int, c: Int) = a + b + c

val a = sum _    // a: (Int, Int, Int) => Int
```
변수 `a`는 함수 값 객체를 나타낸다. 함수 값은 스칼라 컴파일러가 `sum _`을 해석해 자동으로 만든 어떤 클래스의 인스턴스다. 컴파일러가 만들어낸 클래스에는 인자 3개를 받는 `apply` 메소드가 있다. 자동 생성 클래스의 `apply` 메소드는 `sum _` 표현식에서 빠진 인자가 3개이기 때문에 3개의 인자를 받는다. 스칼라가 컴파일러가 표현식 `sum _`로 부터 자동으로 만들어낸 `apply` 메소드는 단순하게 3개의 빠진 인자를 `sum`에 전달하고 그 호출 결과를 반환한다.

밑줄이 전체 파라미터 목록을 나타내는 표현식을 이해하는 또 다른 방법은 이런 표현식이 `def`를 함수 값으로 변환한다고 생각하는 것이다. `sum`을 동일한 파라미터 목록과 결과 타입을 갖는 `apply` 메소드를 지닌 함수 값으로 감쌀 수 있다. 메소드나 중첩 함수를 변수에 할당하거나, 다른 함수에 인자로 전달할 수 없지만 `_`를 사용해서 함수 값으로 변환한다면 가능하다.

```scala
val b = sum(1, _: Int, 3)    // b: (Int) => Int
```

스칼라 컴파일러는 인자를 하나만 받는 `apply` 메소드가 들어 있는 새로운 함수 클래스를 만든다. 만들어진 함수에 하나의 인자를 전달해 수행하면, 해당 함수의 `apply` 메소드는 `1`, 전달한 인자, `3`을 가지고 `sum`을 호출한다.

## 클로져
함수 리터럴은 다른 곳에서 정의한 변수를 참조할 수도 있다.

```scala
(x: Int) => x + more
```
위 함수는 인자에 `more`를 더하는데, `more`가 무엇일까? 주어진 함수의 관점으로 보면 변수 `more`는 함수 리터럴에서 의미를 부여한 것이 아니기 때문에 **자유 변수**다. 대조적으로 변수 `x`는 주어진 함수의 문맥에서만 의미가 있으므로 **바운드 변수**다. 이 `x`는 주어진 함수의 유일한 인자다. 스코프 내에 `more`가 없는 상태에서 작성한 함수 리터럴을 그대로 사용하려고 하면 컴파일러가 오류를 발생시킨다.

```scala
var more = 1
val addMore = (x: Int) => x + more
addMore(10)    // 11
```

주어진 함수 리터럴로부터 실행 시점에 만들어낸 객체인 함수 값(객체)을 **클로져**라고 부른다. 클로져라는 이름은 함수 리터럴의 본문에 있는 모든 자유 변수에 대한 바인딩(변수 이름과 스코프상에서 실제 값 또는 변수 위치 등에 대한 연결)을 '포획'해서 자유 변수가 없게 '닫는' 행위에서 따온 말이다. `(x: Int) => x + 1`과 같이 자유 변수가 없는 함수 리터럴을 **닫히 코드 조각**이라고 부른다. 이렇게 닫힌 함수 리터럴에서 실행 시점에 생긴 함수 값은 엄밀히 말해 클로져가 아니다. `(x: Int) => x + 1`은 이미 닫혀 있기 때문이다. 하지만 `(x: Int) => x + more`처럼 자유 변수가 있는 함수 리터럴은 **열린 코드 조각**이다. 따라서 `(x: Int) => x + more`를 가지고 실행 시점에 만들어내는 함수 값은 정의에 따라 자유 변수인 `more`의 바인딩을 포획해야 한다. 그렇게 해서 만들어진 함수 값에는 포획한 `more` 변수에 대한 참조가 들어 있기 때문에, 클로져라 부른다. 함수 값은 열린 코드 조각 `(x: Int) => x + more`를 닫는 행위의 최종 결과물이기 때문이다.

이 예제를 보면 `more` 를 클로져가 생긴 후 바꾸면 어떻게 될까 하는 궁금함이 생긴다. 스칼라에서는 클로져가 변화를 감지한다는 것이 답이다.

```scala
more = 9999
addMore(10)    // 10009
```
직관적으로 스칼라의 클로져는 변수가 참조하는 값이 아닌 변수 자체를 포획한다. 이전 예제가 보여주듯, `(x: Int) => x + more`에서 생겨난 클로져는 클로져 밖에서 `more`에 발생한 변화를 감지한다. 반대 방향도 마찬가지다. 클로져 안에서 포획한 변수를 변경하면 클로져 밖에서도 볼 수 있다. 

```scala
val someNumbers = List(-11, -10, -5, 0, 5, 10)
var sum = 0
someNumbers.foreach(sum += _)    // sum = -11
```
예제에서는 `List`내의 숫자를 더하되 우회적으로 더했다. `sum` 변수는 `sum`에 숫자를 더하는 함수 리터럴 `sum += _`의 외부 스코프에 있다. `sum`을 변경하는 것은 실행 시점에 만들어진 클로져이지만, 최종 합인 `-11`은 클로져 외부에서도 참조 가능하다.

프로그램을 수행할 때 다수의 복사본을 갖고 있는 변수를 클로져에서 접근하면 어떻게 될까? 예를 들어 클로져가 어떤 함수의 지역 변수를 사용하고, 그 함수를 여러 번 호출한다면 어떻게 될까? 매번 클로져가 그 변수에 접근할 때 어떤 변수를 사용하게 될까?

답은 스칼라 언어의 나머지 부분과 일관성이 있다. 즉 클로져를 만들 때 사용할 수 있었던 인스턴스를 사용한다. 다음은, '증가시키는' 클로져를 만들어서 반환하는 함수다.

```scala
def makeIncreaser(more: Int) = (x: Int) => x + more
```
이 함수를 호출할 때마다 새로운 클로져가 생긴다. 각 클로져는 생성 시점에 활성화되어 있던 `more` 변수에 접근한다.

```scala
val inc1 = makeIncreaser(1)          // (Int) => Int
val inc9999 = makeIncreaser(9999)    // (Int) => Int
```

`makeIncreaser(1)`을 호출하면, 클로져가 하나 생기고 그 안에서 `more`를 `1`로 바인딩한다. 마찬가지로, `makeIncreaser(9999)`를 호출하면 `more`에 `9999`가 들어가 있는 새로운 클로져를 반환한다. 이들 클로져에 인자를 적용하면, 클로져 생성 시 `more`의 값이 어떤 것이었는지에 따라 결과가 달라진다.

```scala
inc1(10)        // 11
incl9999(10)    // 10009
```

여기서는 클로져 안의 `more`가 이미 호출이 끝난 메소드(`makeIncreaser`)의 인자를 사용하지만, 그렇다고 차이가 생기지는 않는다. 스칼라 컴파일러가 인자를 포획하면서 클로져를 만들어내는 메소드보다 더 오래 살아남을 수 있게 힙을 재배치하기 때문이다. 포획한 인자가 스택이 아닌 힙에 있기 때문에 `makeIncreaser` 메소드보다 더 오래 살아남을 수 있다. 컴파일러가 자동으로 이런 재배치를 처리해주므로 걱정할 필요가 없다. 결론적으로 `val`, `var`, 파라미터 어떤 변수이든 포획해도 좋다.