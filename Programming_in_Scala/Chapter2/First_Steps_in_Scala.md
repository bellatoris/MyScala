# Chapter2 First Scala

## 1단계: 스칼라 인터프리터 사용법을 익히자
Command line에서 scala 라고 입력하면 shell을 시작할 수 있다.

```
scala> 1 + 2
res0: Int = 3
```
이 줄에 있는 정보는 다음과 같다.
* 계산 결과 값을 나타앨 때 사용할 수 있는, 자동으로 만들어졌거나 사용자가 정의한 이름(여기서는 `res`였다. 이는 0번째 결과`result`라는 뜻이다.)
* 콜론(:)과 결과의 타입(여기서는 `Int`)
* 등호(=)
* 사용자가 입력한 표현식을 계산해 얻은 결과 값(여기서는 `3`)

`Int`타입은 `scala`패키지의 `Int`클래스를 말한다. 스칼라 패키지는 정보 은닉`Information hiding`을 위한 메커니즘을 제공하고 전역 네임스페이스`global namespace`를 분할해준다는 점에서 자바 패키지와 비슷하다. `Int`클래스의 값은 자바 `int`값에 대응한다. 더 일반적으로, 자바의 모든 원시 타입은 스칼라 패키지에 그와 대응하는 클래스가 들어 있다. 예를 들어 `scala.Boolean`은 자바 `boolean`과, `scala.Float`는 자바 `float`와 대응한다. 또한 원시 타입을 사용해 성능상 이점을 얻을 수 있도록, 이런 클래스에 속한 값을 사용하는 스칼라 코드를 자바 바이트코드로 컴파일하면, 컴파일러는 가능한 자바 원시 코드를 사용한 코드를 생성한다. 

## 2단계: 변수를 정의해보자
스칼라에는 두 종류의 변수가 있는데, 바로 `val`과 `var`이다. `val`은 자바의 `final`변수와 비슷하다. 일단 초기화하고 나면 `val`을 결코 다시 할당할 수는 없다. 반면, `var`는 자바의 `final`이 아닌 변수와 비슷하다. `var`는 없어질 때까지 계속 재할당이 가능하다. 다음은 `val` 정의다.

```
scala> val msg = "Hello, world!"
msg: java.lang.String = Hello, world!
```
이 문장은 `"Hello, world!"`라는 문자열의 이름으로 `msg`를 지정한다. `msg`의 타입은 `java.lang.String`이다. 스칼라는 문자열을 자바 `String` 클래스로 구현하기 때문이다.  
`msg`를 정의하는데 있어서 `String`이나 `java.lang.String`을 입력하지 않았다. 이 예제는 **타입추론**, 즉 표시하지 않은 타입을 스칼라가 알아내는 능력을 보여준다. 스칼라 인터프리터(또는 컴파일러)가 타입을 추론할 수 있는 경우라면, 그냥 컴파일러가 추론하게 두는 편이 더 낫다. 하지만 원한다면 타입을 직접 지정할 수도 있고, 때에 따라서는 꼭 그래야만 하는 경우도 있다. 타입 지정을 해두면 스칼라 컴파일러가 의도한 타입을 추론하는지 확실히 할 수 있고, 나중에 코드를 읽을 독자들에게 코드를 문서화하는 효과도 있다.

```
scala> val msg2: java.lang.String = "Hello again, world!"
msg2: java.lang.String = Hello again, world!
```
`var`가 아니라 `val`로 정의한 `msg`로 할 수 없는 일은 바로 재할당이다. 재할당을 하고 싶다면 `var`를 사용하여야 한다.

## 3단계: 함수를 정의해보자

```
scala> def max(x: Int, y: Int): Int = {
			if (x > y) x
			else y
		}
max: (x:Int, y: Int) Int
```
함수 정의는 `def`로 시작한다. 그 다음에 함수 이름(여기서는 `max`) 이 오고, 그 뒤에 괄호 안에 콤마(,)로 구분한 파라미터`parameter`목록이 온다. 스칼라 컴파일러가 파라미터 타입을 추론하지 않기 때문에, 모든 파라미터에는 콜론 뒤에 타입 지정을 반드시 덧붙여야 한다. 이 예에 있는 `max`함수는 `Int`타입의 인자 `x`와 `y`를 받는다. `max`의 파라미터 목록을 닫는 괄호 뒤에는 또 다른 `': Int'`타입 지정이 있다. 이 타입은 `max`함수의 **결과 타입**`result type`을 정의한다. 함수 결과 타입 뒤에는 등호(=)와 중괄호({})가 온다. 중괄호 안에는 함수의 본문이 들어간다. 이 예제에서는 함수 본문에 `if`표현식 하나만 들어가 있다. 함수형 프로그래밍에서는 함수가 결과를 내놓는 표현식을 정의한다. 함수 본문앞의 등호는 그런 관점을 보여준다.  
때로 스칼라 컴파일러가 함수의 결과 타입을 지정하도록 요구하는 경우가 있다. 예를 들어, 함수가 **재귀적**`recursive`이라면 함수의 결과 타입을 반드시 명시해야만 한다. 하지만 `max`의 경우 결과 타입을 생략해도 좋다. 그러면 컴파일러가 결과 타입을 추론할 것이다. 또한 함수 본문에 문장이 하나밖에 안 들어 있다면, 중괄호를 생략할 수도 있다. 따라서 `max`함수를 다음과 같이 쓸 수도 있다.

```
scala> def max2(x: Int, y: Int) = if (x > y) x else y
max2: (x: Int, y: Int) Int
```
여기 아무 파라미터도 받지 않고 관심이 있을 만한 어떤 결과도 돌려주지 않는 함수 정의가 있다.

```
scala> def greet() = println("Hello, world!")
greet: ()Unit
```
`greet()`함수를 정의하면 인터프리터가 `greet: ()Unit`라고 응답할것이다. `greet`는 물론 정의 한 함수의 이름이다. 빈 관호는 함수 파라미터가 아무것도 없음을 의미한다. `Unit`는 `greet`의 결과 타입이다. `Unit`라는 결과 타입은 함수가 우리가 관심을 가질 만한 값을 반환하지 않는다는 뜻이다. 스칼라의 `Unit`타입은 자바의 `void`타입과 비슷하며, 실제로도 자바에서 `void`를 반환하는 메소드는 스칼라에서 모두 `Unit`를 반환하는 메소드가 된다. 따라서 결과 타입이 `Unit`인 메소드는 부수 효과를 위해서만 실행하는 함수다. `greet()`의 부수 효과는 표준 출력에 `String`을 출력하는 것이다.  
인터프리터를 나갈 때는 `:quit`나 `:q`를 입력하면 된다.

```
scala> :quit
$
```

## 4단계: 스칼라 스크립트를 작성해보자
프로그래머가 아주 큰 시스템을 잘 구축할 수 있도록 스칼라를 설계했지만, 스크립트를 만들 떄도 역시 잘 사용할 수 있다. 스크립트는 파일에 스칼라 문장들을 넣은 것을 말한다. 스칼라는 스크립트의 각 문장을 파일에 있는 순서대로 실행한다. 다음을 hello.scala라는 파일에 넣자.

```scala
println("Hello, world, form a script!")
```
그리고 실행해 보자.

```bash
$ scala hello.scala
```
그러면 또 다른 인사말을 볼 수 있다.

```
Hello, world, from a script!
```
스칼라 스크립트는 `args`라는 스칼라 배열 `array`에 명령행 인자를 받는다. 스칼라의 배열은 0번부터 시작하며, 인데스`index`를 괄호 안에 넣어서 배열의 원소`element`에 접근할 수 있다. 따라서 스칼라 배열의 첫 번째 원소는 `steps[0]`이 아니고 `steps(0)`이다. 이를 테스트하기 위해, 다음 코드를 helloarg.scala라는 파일에 저장하라.

```scala
// 첫 번째 인자에게 인사한다.
println("Hello, " + args(0) + "!")
```
그리고 실행해보자.

```bash
$ scala helloarg.scala planet
Hello, planet!
```
이 명령은 "`planet`"을 명령행 인자로 넘긴다. 스크립트에서는 이 인자를 `args(0)`으로 접근할 수 있다.

## 5단계: while로 루프를 돌고, if로 결정해보자

```scala
var i = 0
while (i < args.length) {
	if (i != 0)
		print(" ")
	print(args(i))
	i += 1
}
println()
```
위의 스크립트를 실행하면, 입력한 문구를 그대로 출력할 것이다.

## 6단계: foreach와 for를 사용해 이터레이션 해보자
앞의 5단계에서 `while`루프를 사용해 작성한 프로그램은 **명령형**`imperative`스타일이다. 명령형 스타일은 보통 자바, C++, C등에서 사용하는 프로그래밍 방식이다. 작동을 지시하는 명령을 한 번에 한나씩 사용하고, 루프로 이터레이션 하면서, 여러 다른 함수 사이에 공유하는 상태를 변경한다. 스칼라에서도 명령형 스타일도 사용 가능하지만, 스카라를 잘 알게 될수록 점점 더 함수형 스타일로 프로그래밍하게 될 것이다.  
함수형 언어의 주요 특성 중 하나는 함수가 1급 계층 요소라는 것이다. 스칼라도 마찬가지다. 예를 들어, 명령행 인자를 모두 다 출력하는 또 다른(그리고 더 간결함) 방법은 다음과 같다.

```scala
args.foreach(arg => println(arg))
```
이 코드는 `args`에 있는 `foreach`메소드를 호출한다. 그리고 인자로 함수를 넘긴다. 여기서는 `arg`라는 파라미터를 받는 **함수 리터럴**`function literal`을 사용했다. 이 함수의 본문은 `println(arg)`이다. 여기서 스칼라 컴파일러가 `arg`의 타입이 `String`임을 추론했다. 왜냐하면 `String`이 `foreach`를 호출한 대상 객체인 배열 `args`의 원소 타입이 `String`이기 때문이다.   
명확한 것보다 간결한 것을 더 바란다면, 스칼라가 제공하는 축약형을 쓸 수 있다. 함수 리터럴이 인자를 하나만 받는 문장인 경우에는 해당 인자에 이름을 붙일 필요가 없다. 따라서 다음과 같은 코드도 마찬가지로 잘 동작한다.

```scala
args.foreach(println)
```
정리하면, 함수 리터럴의 문법은 파라미터 이름의 목록이 괄호 안에 오고, 그 뒤에 오른쪽 화살표, 마지막으로 함수의 본문이 있어야 한다. 

```scala
(x: Int, y: Int) => x + y
```
스칼라에서는 명령형 `for`에 대한 함수형 친척(`for expression이라 부른다`)을 사용할 수 있다.

```scala
for (arg <- args)
	pritln(arg)
```
`arg`는 `val`의 이름이며, 결코 `var`의 이름이 아니다. `for`루프를 돌 때마다 `arg`가 새 값이 들어가기 때문에, `arg`가 `var`처럼 보일지 몰라도 실제로는 `val`이다. 그래서 `for`표현식의 본문에서 `arg`를 재할당할 수 없다.