# Programming in Scala

### 스칼라를 어떻게 배울 것인가?
* 책이 제공하는 다양한 프로그래밍 예제를 직접해보자.
* 예제를 여러가지로 변형해보는 것은 예제를 더 재미있게 만들고 각 동작을 제대로 이해 했는지 확인 할 수 있다.
* 책을 충분히 읽었다면 스스로 프로그래밍 프로젝트를 만들어 보자.
	* 작은 프로그램을 바닥부터 만들어보고, 더 큰 프로그램에 들어가는 애드인을 만들어보자.
* **책을 읽기만 해서는 그리 멀리 나아갈 수 없다.**

### 소스 코드 
이 책의 소스 코드가 담긴 ZIP 파일을 내려받을 수 있다.  
[Link1](http://booksites.artima.com/programming_in_scala_2ed)

# Chatper 1. A Scalable Language 

Scala 라는 이름은 Scalable Language 라는 뜻이다. 스칼라 사용자는 작은 스크립트를 작성하는 일부터, 커다란 시스템을 구축하는 일까지 광버위한 프로그래밍 과업에 스칼라를 활용할 수 있다. 기술적으로, 스칼라는 객체지향과 함수형 프로그래밍 개념을 정적 타입 언어에 합쳐 놓은 언어다. 마틴 오더스키에 의하면 객체지향 패러다임과 함수형 패러다임은 orthogonal 하기 떄문에 객체지향 + 명령형 프로그래밍도 가능하며 객체지향 + 함수형 프로그래밍도 가능한 것이다.  
스칼라는 널리 쓰이는 여타 언어들에 비해 더 광범위하다고 말할 수 있다. 규모 확장성 측면에서 두 프로그래밍 스타일에는 상호 보완적인 강점이 있다. 스칼라의 함수형 프로그래밍 구성요소를 사용하면 관심 대상을 간단한 부품으로부터 빠르고 쉽게 만들 수 있다. 스칼라의 객체지향 구성요소를 사용하면 더 큰 시스템을 구조화하고 새로운 요구에 맞춰 구조를 쉽게 변형할 수 있다.


## 1.1 점점 여러분의 마음에서 자라가는 언어
스칼라는 편리함과 유연성을 동시에 제공한다. 스칼라는 빠르게 익혀서 시작할 수 있고 즐겁게 간결한 스탈일로 프로그램할 수 있는 편리한 구성요소를 제공한다. 동시에, 스칼라는 여러분의 생각이 언어에 의해 제약받는 일이 없도록 보장한다. 

### 새로운 타입을 키워가기
성당은 완벽에 가까운 건물로 짓는 데 오랜 시간이 걸린다. 일단 다 건설하고 나면 성당은 오랫동안 그대로 남는다. 반면, 시장은 내부에서 일하는 사람들이 매일 상황에 맞게 변경하고 확장한다. 스칼라는 성당보다는 시장에 가까운 언어다. 이 언어를 사용하는 사람들이 확장하고 변경할 수 있도록 설계되어있다는 점에서 그렇다.

```scala
def factorial(x: BigInt): BigInt = 
	if (x == 0) 1 else x * factoial(x - 1)
```
`BigInt`는 내장 타입과 같아 보인다. 정수 리터럴이나  *, - 등의 연산자를 해당 타입의 값에 그대로 사용할 수 있기 때문이다. 하지만 이 클래스도 스칼라의 표준 라이브러리에 들어 있는 평범한 클래스일 뿐이다. (연산자들을 오버라이딩 할 수 있게 해놔서 위의 예제가 가능한 것이다.) 스칼라는 언어가 기본 지원하는 것처럼 느껴지는, 쉽게 사용할 수 있는 라이브러리를 통해 언어를 사용자가 필요한 방향으로 확장하고 고칠 수 있게 허용한다.

### 새로운 제어 구조 키워가기
스칼라는 확장성 원칙을 제어 구조에도 마찬가지로 적용한다. 이러한 확장성을 스칼라 API의 '액터 기반' 동시성 프로그래밍 API에서 볼 수 있다. 멀티 쓰레딩을 완벽하게 하는 것은 매우 어려운일이다. 특히나, 시스템의 크기와 복잡도가 증가할수록 더 그렇다. 안전한 대안은 Erlang 프로그래밍 언어에서 사용하는 '액터'같은 메시지 전달 아키텍쳐일 것이다.  
스칼라는 여타 자바 API와 마찬가지로 스레드 기반 동시성 라이브러리를 활용할 수 있다. 그러나 스칼라는 본질적으로 Erlang의 액터 모델을 구현하는 라이브러리를 추가로 제공한다.  
액터는 스레드 위에 구현할 수 있는 동시성 추상화 요소다. 액터들은 서로 메시지를 보냄으로써 통신한다. 액터가 수행할 수 있는 기본 연산은 메시지 송신과 수신이다. 송신 연산은 느낌표(!)로 표시하며, 메시지를 다른 액터에 보낸다. 다음은 `recipient`라는 액터에 메시지를 보내는 문장이다.

```scala
recipient ! msg
```
송신은 비동기적 `asynchronous`이다. 즉, 메시지를 보낸 액터는 수신자가 메시지를 수신할 때까지 기다릴 필요 없이 즉시 다음 작업을 진행할 수 있다는 뜻이다. 모든 액터에는 들어오는 메시지가 들어가 대기하는 **우편함**`mailbox`이 있다. 또한 액터는 우편함에 도착한 메시지를 `receive`블록을 사용해 처리한다.

```scala
recieve {
	case Msg1 => ... // Msg1을 처리함
	case Msg2 => ... // Msg2을 처리함
	// ...
}
```
`receive` 블록은 우편함의 메시지를 패턴에 따라 처리하는 여러 가지 `case`문장으로 이뤄져 있다. 우편함에 있는 메시지 중 `case`를 하나 만족하는 최초의 메시지를 선택해서, 그에 따른 동작을 수행한다. 주어진 여러 `case`를 만족하는 메시지가 우편함에 하나도 없다면, 액터는 동작을 멈추고 다음 메시지가 도착할 때까지 기다린다.  
  
 예를 들어 다음은 체크섬`checksum` 계산 서비스를 구현하는 스칼라 액터다.
 
```scala
actor {
 	var sum = 0
 	loop {
 		receive {
 			case Data(bytes) 		=> sum += hash(bytes)
 			case GetSum(requester) 	=> requester ! sum
		}
	}
}
```

이 액터의 맨 앞에는 0으로 초기화한 `sum`이라는 변수 선언이 있다. 그 다음에 이 액터는 `loop`와 `receive` 명령을 사용해 메시지를 
기다리는 일을 반복한다. `Data` 메시지를 받을 때마다 그 데이터(`bytes`)의 해시를 계산해 `sum` 변수에 더한다. `GetSum`메시지를 받으면, 요청한 `requestor`에게  `requestor ! sum`이라는 송신 명령을 사용해 현재 `sum`값을 전송한다. `requestor`필드는 `GetSum`메시지 안에 들어 있으며, 보통은 요청을 보냈던 액터를 나타낼 것이다.  
이 예에서 중요한 내용은, 확장성이라는 측면에서 볼 때  `actor`나 `loop`, `receive`, 메시지, 메시지 송신(!) 등이 모두 다 스칼라 내장 기능이 아니라는 점에 있다, `actor`, `loop`, `receive`는 모두 `while`이나 `for`루프처럼 스칼라 내장 구성요소인 것처럼 보인다. 하지만 실제로 이들에 대한 정의는 스칼라 내장 구성요소인 것처럼 보인다. 하지만 실제로 이들에 대한 정의는 스칼라의 액터 라이브러리에 들어 있다. 마찬가지로, '!'가 내장 연산자인 것처럼 보이지만 그 역시도 액터 라이브러리에서 정의한 연산자다. 이 네 가지 (액터) 구성요소는 모두 스칼라 프로그래밍 언어와는 완전히 별개다.  
스칼라의 `receive`블록이나 송신(!) 문법은 Erlang과 매우 비슷하다. 하지만 Erlang은 이런 요소를 언어에 내장해 제공한다. 스칼라는 Erlang이 제공하는 그 밖의 동시성 프로그래밍 구성요소도 구현해 제공한다. 예를 들어 실패한 액터를 모니터링하는 기능이나, 타임아웃 등을 구현한다. 대체로 액터는 동시적인 분산 컴퓨팅을 표현하기에 아주 쾌적한 도구임이 드러났다. 라이브러리임에도 불구하고, 액터는 스칼라 언어와 완전히 하나인 것처럼 보인다.  
이 예제는 스칼라 언어를 동시성 프로그래밍과 같이 특별한 분야로까지 '키울'수 있음을 보여준다. 물론 이를 위해서는 훌륭한 아키텍트와 프로그래머가 설계해야 하겠지만, 그런 일이 가능하다는 사실 자체가 중요하다. 즉, 전혀 새로운 애플리케이션 분야를 처리하는 추상화를 스칼라에서 설계하고 구현할 수 있으며, 그럼에도 마치 언어가 원래부터 지원하는 것처럼 느끼게 할 수 있다.

## 1.2 스칼라의 확장성이 가능한 이유
스칼라의 확장성에 가장 큰 영향을 끼치는 요인은 객체지향과 함수형 프로그래밍의 조합이다.  
객체지향과 함수형 프로그래밍을 일관성 있게 언어 설계에 녹여낸다는 측면에서 슼탈라는 그 밖의 잘 알려진 언어보다 훨씬 더 나아갔다. 예를 들어 여타 언어에서는 객체와 함수가 별개의 개념일 수 있지만, 스칼라에서는 함수 값도 객체다. 함수 타입은 서브클래스가 상속할 수 있는 클래스다. 이런 특징이 학문적인 아름다움에 불과한 것 같아 보이겠지만, 확장성 측면에서 미치는 결과가 크다. 실제로 앞에서 보여준 액터 개념은 이렇게 함수와 객체를 통합하지 않았다면 구현할 수 없었을 것이다. 

### 스칼라는 객체 지향적이다
객체지향 프로그래밍의 동기는 아주 간단하다. 모든 프로그램은 일조의 구조가 필요한데, 구조를 만드는 가장 직접적인 발명은 데이터와 연산을 어떤 그릇에 담는 것이다. 객체지향 프로그래밍의 위대한 아이디어는 이런 그릇을 아주 일반적으로 만들어서, 내부에 데이터뿐만 아니라 연산까지 포함시키고, 이런 그릇을 다시 다른 그릇에 담거나, 연산에 파라미터로 넘길 수 있는 값으로 취급하는데 있다. 이런 그릇을 일컬어 객체 `object`라 한다. 앨런 케이는 이런 방법을 사용하면 가장 간닿나 객체에도 완전한 컴퓨터와 마찬가지 구축 원칙 (즉, 데이터를 연산과 함께 묶어서 잘 정의한 인터페이스를 통해 제공하는 것)을 적용할 수 있다고 말한다. 따라서 작은 프로그램을 작성하는데 사용한 기법과 동일한 기법을 큰 프로그램을 작성할 때도 적용할 수 있다는 점에서 객체는 언어의 확장성과 많은 관련이 있다.  
스칼라는 순수한 형태의 객체지향 언어다. 모든 값이 객체이며, 모든 연산은 메소드 호출이다. 예를 들어 스칼라에서 `1 + 2`라고 쓰면, 실제는 `Int`클래스가 정의한 `+`라는 이름의 메소드를 호출하는 것이다. API 사용자가 연산자 표기법으로 사용할 수 있는, 연산자와 비슷한 이름을 가진 메소드를 정의할 수 있다. 
객체를 조합함에 있어, 스칼라는 매우 뛰어나다. 그런 예로 스칼라의 **트레이트**`trait`를 들 수 있다. 트레이트는 자바의 인터페이스와 비슷하다. 하지만 트레이트 안에서 메소드를 정의할 수 있고, 심지어 필드도 정의할 수 있다. 객체는 **믹스인**`mixin`**조합**을 통해 만들 수 있다. 믹스인은 한 클래스의 멤버에 다른 트레이트에서 가져온 멤버들을 추가하는 것이다. 트레이트는 다중상속`multiple inheritance`와 다르다. 꼭 상속을 통해야만 하는 클래스와 달리, 새로운 기능을 아무 서브클래스에나 섞어 넣을 수 있다. 이로 인해 트레이트는 클래스보다 더 '끼워 넣기 좋은`pluggable`' 구성요소이다.

### 스칼라는 함수형이다
스칼라는 또한 완전한 함수형 언어다. 함수형 프로그래밍은 두 가지 주요 아이디어에 따라 방향이 정해진다. 첫 번째 아이디어는 함수가 1급 계층 `first class`값이라는 점이다. 함수형 언어에서 함수는 정수나 문자열과 동일한 자격을 갖는 값이다 . 함수를 다른 함수에 인자로 넘길 수 있고, 함수 안에서 결과로 함수를 반환할 수도 있고, 함수를 변수에 저장할 수도 있다. 또한 함수 안에서 정수 값을 정의할 수 있는 것처럼, 다른 함수의 내부에서 함수를 정의할 수도 있다. 심지어 함수 이름을 지정하지 않고 함수를 정의할 수도 있다.  
1급 계층값인 함수는 연산을 추상화하거나 새로운 제어 구조를 만들어내는 데 있어 좋은 수단이다. 이렇게 함수를 일반화해두면 표현력이 엄청나게 늘어나기 때문에, 아주 읽기 쉬우면서 간결한 프로그램을 만들 수 있다. 이러한 특징은 확장성에서도 중요한 역할을 한다.
  
함수형 프로그래밍의 두 번째 주 아이디어는 프로그램은 입력 값을 출력 값으로 변환해야 하며, 데이터를 그 자리에서 변경하지 말아야 한다는 점이다. 변경 불가능한 데이터 구조는 함수형 프로그래밍의 초석 중 하나다.  
이런 함수형 프로그래밍의 두 번째 아이디어는 '메소드에는 **부수 효과**`side effect`가 없어야 한다'라고 다르게 표현할 수 있다. 메소드는 인자를 받아서 결과를 반환하는 방식으로만 주변 환경과 통신해야 한다. 메소드는  **참조 투명**`referentially transparent`해야 한다. 주어진 입력에 대해, 프로그램의 의미에 전혀 영향을 주지 않고 어떤 메소드 호출 부분을 그 메소드를 호출해 얻은 결과 값으로 치환할 수 있다는 말이다.  
함수형 언어는 변경 불가능한 데이터와 참조 투명한 메소드를 장려한다. 몇몇 함수형 언어는 이런 성질만을 요구하기도 한다. 스칼라에서는 원하는 대로 선택이 가능하다. 원한다면 변경 가능한 데이터와 부수 효과를 사용하는 **명령형**`imperative`프로그램을 작성할 수도 있다. 하지만, 스칼라가 이미 좋은 함수형 대안을 제공하기 때문에 명령형 구성요소의 사용을 쉽게 피할 수 있다.

## 1.3 왜 스칼라인가?
확장성 말고도 스칼라에는 중요한 네 가지 측면 호환성, 간결성, 고수준 추상화, 고급 정적 타이핑이 존재한다.

### 스칼라는 호환성이 좋다
스칼라 프로그램은 JVM 바이트코드로 컴파일되며, 그 프로그램의 실행 성능은 보통 자바 프로그램과 대등하다. 스칼라 코드가 자바 메소드를 호출하거나, 자바 필드에 접근하거나, 자바 클래스를 상속하거나, 자바 인터페이스를 구현할 수도 있다.
완전한 상호운용성`interoperabiltity`의 또 다른 측면으로는 스칼라가 자바 타입을 아주 많이 재사용한다는 점이 있다.  

### 스칼라는 간결하다
스칼라 문법은 자바 프로그램이라면 꼭 있어야 할 지루하고 무거운 얼개 코드를 피한다. 다음의 코드를 비교해 보자.

```java
class MyClass {
	private int index;
	private String name;
	
	public MyClass(int index, String name) {
		this.index = index;
		this.name = name;
	}
}
```
스칼라에서는 위 코드를 다음과 같이 쓸 수 있다.

```scala
class MyClass(index: Int, name: String)
```
스칼라 컴파일러가 이 코드를 보면 두 비공개 인스턴스 변수를 만들고, 이런 인스턴스 변수를 초기화하기 위한 값을 파라미터로 받는 생성자를 만든다. 스칼라 버전은 더 긴 자바 버전과 근본적으로 동일한 기능을 한다. 스칼라 클래스는 더 빨리 작성할 수 있고, 읽기 쉽다. 가장 중요한 것은, 자바 클래스보다 스칼라 클래스 쪽이 오류를 낼 가능성이 더 낮다는 점이다.  
스칼라 타입 추론`type inference`은 이런 간결성을 가능하게 하는 또 다른 요소다. 반복적으로 타입 정보를 쓸 필요가 없기 때문에, 프로그램이 덜 어수선하고 더 읽기 좋아진다. (타입 정보를 안쓰는게 프로그램이 더 읽기 좋아지나? 나 같은 경우 타입 정보가 있을 때 프로그램을 이해하는데 드는 시간이 더 짧은 것 같다.)  
하지만 간결한 ㅋ드의 가장 핵심적인 요소는 바로 라이브러리에 이미 코드가 있어서 직접 작성할 필요가 없어지는 코드일 것이다. 스칼라는 일반적인 동작을 묶어서 잡아내어 강력한 라이브러리를 정의할 수 있는 도구를 많이 제공한다. 예를 들어 라이브러리 클래스의 여러 측면을 각각 별도의 트레이트에 분리해 넣을 수 있다. 그 후, 각각을 유연하게 섞어 사용할 수 있다. 또한 라이브러리 메소드가 다른 연산을 파라미터로 받으 수 있다. 그에 따라, 사실상 자신만의 제어 구조를 제공하는 구성요소를 만들 수 있다. 이런 요소를 한데 모으면, 고수준이면서 유연하게 사용할 수 있는 라이브러리를 정의할 수 있다.

### 스칼라는 고수준이다.
프로그래머는 계속 복잡함과 격렬히 싸우고 있다. 중요한 소프트웨어는 보통 요구사항이 복잡하므로, 이러한 복잡성을 피할 수 없다. 대신에, 복잡성을 관리해야만 한다.  
스칼라를 사용하면 설계하고 사용하는 인터페이스의 추상화 수준을 높여서 복잡성을 관리할 수 있다. 예를 들어 `name`이라는 `String`타입의 값이 있다고 하자. 그리고 그 문자열에 대문자가 들어 있는지 확인하고 싶다고 치자. 자바 코드는 다음과 같다.

```java
boolean nameHasUpperCase = false;
for (int i = 0; i < name.length(); i++) {
	if (Character.isUpperCase(name.charAt(i))) {
		nameHasUpperCase = true;
		break;
	}
}
```
반면 스칼라에서는 다음과 같이 쓸 것이다.

```scala
val nameHasUpperCase = name.exists(_.isUpper)
```
자바 코드는 루프 안에서 각 문자를 하나하나 다루는 방식으로 문자열을 낮은 수준의 대상으로 다룬다. 스칼라 코드는 같은 문자열을 **술어**`predicate`를 사용해 질의가 가능한 더 높은 수준의 문자 시퀀스로 다룬다. 스칼라 코드가 분명히 더 짧고, 자바 코드보다 이해하기 쉽다. 따라서 스칼라 코드는 전체 복잡성을 계산해보면 자바 보다 훨씬 더 가볍다.  
술어인 `_.isUpper`는 스칼라의 함수 리터럴`function literal`의 한 예다. 이 표현식은 문자를 인자로 받아서 그 문자가 대문자인지 검사하는 함수를 표현한다.  
원론적으로, 이런 제어 추상화를 자바에서도 할 수 있다. 아마도 이런 추상화한 기능을 제공하는 메소드가 들어 있는 인터페이스를 정의해야 할 필요가 있을 것이다. 예를 들어, 문자열에 대해 질의를 하고 싶다면, `hasProperty`라는 메소드만 하나 들어 있는 `CharacterProperty`같은 이름의 인터페이스를 만들어야 할 것이다.

```java
inteface CharacterProperty {
	boolean hasProperty(char ch);
}
```
이런 인터페이스가 있다면, 자바에서도 문자열과  `CharacterProperty`를 인자로 받는 `exists`라는 메소드를 만들어 낼 수 있었을 것이다. 그 메소드는 문자열에 있는 문자 중에 지정한 프로퍼티를 만족하는 문자가 있다면 `true`를 반환할 것이다. 그러면 다음과 같이 `exists`를 호출할 수 있다.

```java
exists(name, new CharacterProperty() {
	public voolean hasProperty(char ch) {
		return Character.isUpperCase(ch);
	}
});
```
하지만 이런 과정은 꽤 무겁게 느껴진다. 실제로는 너무 무겁기 때문에 이렇게 귀찮게 처리하는 자바 프로그래머는 거의 없을 것이다. 대신 보통 자바 프로그래머들은 루프를 작성하고, 코드 안에서 늘어난 복잡성과 함께 살아간다. 반면, 스칼라의 함수 리터럴은 아주 가볍기 때문에 프로그래머들은 이를 자주 사용한다. 스칼라를 더 잘 알수록, 제어를 추상화하는 코드를 작성하고 사용할 기회가 더더욱 많아질 것이다. 제어 추상화를 사용하면 코드 중복을 피할 수 있고, 코드를 더 짧고 간결하게 만들 수 있다는 사실을 꺠달을 것이다.

### 스칼라는 정적 타입 언어다
정적 타입 시스템`static type system`은 변수나 표현식이 저장하거나 계산하는 값의 종류에 따라 이들을 분류한다. 스칼라는 아주 진보적인 정적 타입 시스템을 가진 언어로 독보적이다. 자바와 비슷한 중첩 클래스 타입으로부터 시작해서, **제네릭**`generic`과 파라미터화한 타입을 허용하며, **교집합**`intersection`을 사용해 타입을 조합할 수도 있고, **추상 타입**`abstract type`을 사용해 어떤 타입에서 상세 내용을 감출 수도 있다. 스칼라 타입 시스템은 안전하면서 동시에 사용하기에 유연한 인터페이스를 설계할 수 있도록 타입을 조합하고 만들어내는 데 있어 튼튼한 기초를 제공한다.

#### 프로퍼티 검증
정적 타입 시스템은 어떤 종류의 실행 시점 오류가 없음을 증명할 수 있다. 예를 들어, 타입 시스템은 불리언`boolean`을 정수에 결코 더하지 않는다는 점 , 비공개 변수를 클래스 외부에서 접근하지 않는다는 사실, 함수 적용 시 인자 개수를 틀리지 않았다는 점, 문자열 집합에 문자열만 추가하는지 여부등을 검증할 수 있다. 물론 타입 시스템이 감지할 수 없는 오류 유형들이 존재하지만, 그렇다고 하여 타입 시스템이 쓸모 없는 것은 아니다. 분명히 정적 타입 시스템은 단위 테스트 (Unit Test?)를 대치할 수 없지만, 타입을 잘 설계한다면 타입이 없을 경우 단위 테스트에서 다뤄야만 했을 여러 테스트 케이스를 줄여줄 수 있다. 마찬가지로, 단위 테스트가 정적 타입을 대치할 수도 없다. 정적 타입은 보장해주는 내용이 단순할 수는 있지만, 아무리 테스트를 많이 추가해도 보장할 수 없는 것을 실제적으로 보장해준다.

#### 안전한 리팩토링
정적 타이핑은 여러분이 코드 베이스를 상당한 자신감을 가지고 변경할 수 있는 안전망 역할을 한다. 메소드에 파라미터를 하나 더 넣은 리팩토링을 생각해보자. 정적 타입을 사용하는 언어에서는 코드를 변경하고, 시스템을 재컴파일해서 타입 오류를 일으킨 모든 행을 수정하면 된다. 이 과정이 끝나고 나면, 여러분은 변경이 필요한 모든 곳을 제대로 고쳤다고 확신할 수 있다. 마찬가지 명제가 메소드 이름 바꾸기, 메소드를 한 클래스에서 다른 클래스로 옮기기 등의 단순한 리팩토링에 대해 성립한다. 이 모든 경우, 정적인 타입 체크를 사용하면 새로운 시스템이 예전 것과 마찬가지로 잘 동작하리라는 확신을 가질 수 있다.

#### 문서화
정적 타입은 컴파일러가 정확성을 검증하기 위해 사용하는 프로그램 문서화다. 일반적인 주석과 달리, 타입 표기는 소스 코드의 갱신을 못 따라가는 일이 없다. 게다가, 컴파일러나 IDE는 타입 정보를 사용해 문맥 도움말을 더 좋게 만들 수 있다.  
정적 타입이 프로그램 문서화에 유용하기는 하지만, 타입 표기가 프로그램을 어수선하게 만들면 때로는 짜증스럽기도 하다. 보통, 문서화가 유용하려면 독자가 프로그램을 보고 쉽게 알 수 없는 내용을 기술해야 한다. 다음과 같은 메소드 정의가 있다고 하자.

```scala
def f(x: String) = ...
```
`f`의 인자가 `String`이어야 한다는 사실을 아는 것은 유용하다. 하지만 아래 예제에 있는 두 타입 표기 중 적어도 하나는 짜증 나는것이다.

```scala
val x: HashMap[Int, String] = new HashMap[Int, String]()
```
여기서는 분명 `x`를 `Int`가 키이고 `String`이 값인 `HashMap`이라고 표시하는 것으로 충분하다. 같은 구문을 두 번 반복할 필요가 전혀 없다.  
스칼라는 아주 정교한 타입 추론 시스템을 사용해 프로그래머가 짜증 낼 만한 위치에 타입 표기를 하는 일이 없도록 돕는다. 앞의 예를 보자면, 다음과 같이 덜 짜증 나는 표현을 사용해도 된다.

 ```scala
 val x = new HashMap[Int, String]()
 val x: Map[Int, String] = new HashMap()
 ```
 스칼라 타입 추론은 훨씬 더 멀리 나아갈 수 있다. 실제로, 사용자가 코드에 타입을 전혀 명시하지 않는 경우도 드물지 않다. 따라서 스칼라 프로그램이 동적 타입 언어로 작성한 코드와 어느 정도 비슷해 보이는 경우도 종종 있다. 특히 이미 존재하는 라이브러리를 서로 이어붙이는 클라이언트 애플리케이션 코드의 경우에는 더 그렇다. 하지만 라이브러리 코드 자체는 덜 그렇다. 라이브러리 코드는 유연한 사용 패턴을 허영하기 위해 아주 정교하게 설계한 타입을 적용하는 경우가 많기 때문이다. 재사용 사능한 컴포넌트의 인터페이스를 이루는 멤버의 타입 시그니처`signature`는 명시해야만 한다. 이런 멤버는 컴포넌트와 그 컴포넌트를 사용하는 클라이언트의 사이의 계약에 있어 핵심적인 부분이기 때문이다.
 
## 1.4 스칼라의 뿌리
 스칼라는 설계 당시 여러 프로그래밍 언어와 프로그래밍 언어 학계의 아이디어로부터 영향을 받았다. 실제로, 스칼라의 특징 중 스칼라가 원조인 것은 거의 없다.대부분은 다른 언어에서 어떤 형태로든 이미 사용해봤던 것이다. 스칼라의 혁신은 주로 이런 구성요소를 함께 조합하는 방법에 있다. 이번 절에서는 스칼라 설계에 큰 영향을 끼친 요소를 살펴볼 것이다.  
 표면적으로 보면, 스칼라는 대부분의 문법을 자바와 C#에서 빌려왔다. 물론 자바나 C#역시 C나 C++의 문법적인 관습을 많이 차용했다. 표현식, 명령문, 블록등은 자바와 거의 같고, 클래스, 패키지, 임포트 등도 마찬기자. 스칼라는 문법 외에도 기본 타입, 클래스 라이브러리, 실행 모델 등에 있어 자바의 요소를 도입했다.  
 스칼라는 그 밖의 언어에서도 빋을 많이 지고 있다. 스칼라가 채택한 일관성 있는 객체 모델`uniform object model`은 스몰토크가 선구적으로 사용했고, 루비가 그 뒤를 이어왔다. 보편적인 내포(스칼라에서는 거의 대부분의 구성요소 내부에 다른 구성요소를 내포할 수 있다)는 알골`Algol`, 시뮬라, 그리고 최근의 베타`Beta`와 gbeta에서 볼 수 있다. 메소드 호출과 필드 선택을 동일하게 처리하는 단일 접근 원칙은 에펠`Eiffel`에서 온 것이다. 스칼라가 택한 함수형 프로그래밍 접근 방식은 ML 계열 언어의 정신과 매우 비슷하다. ML 계열 언어의 주 멤버로는 SML, 오캐멀`OCamel`, F#이 있다. 스칼라 표준 라이브러리에 있는 고차 함수`high order function` 중 다수는 ML이나 하스켈에도 있는 것이다. 스칼라의 암시적 파라미터는 하스켈의 타입 클래스로부터 영향을 받았다. 하스켈은 더 전통적인 객체지향 환경하에서 타입 클래스를 통해 비슷한 결과를 얻을 수 있었다. 스칼라가 사용하는 액터 기반 동시성 라이브러리는 Erlang에서 큰 영향을 받았다.  
 스칼라가 규모 확장성`scalability`과 확장성`extensibility`을 강조한 최초의 언어는 아니다. 확장 가능한 언어의 역사적인 뿌리는 다른 적용 분야까지 폭넓게 고려하면 피터 란딘`Peter Landin`의 1966년 논문 '새로운 700개 프로그래밍 언어`The Next 700 Programming Languages`'로 거슬러 올라갈 수 있다. 중위 연산자를 함수처럼 다루자는 아이디어는 이즈웜이나 스몰토크 까지 거슬러 올라갈 수 있다. 또 다른 중요한 아이디어는 함수 리터럴(또는 블록)을 파라미터로 넘길 수 있게 허용하는 것이다. 이를 통해 라이브리에서 제어 구조를 정의할 수 있다. 이 또한 이즈웜과 스몰토크에서 비롯된 것이다. 스몰토크와 리스프는 둘 다 내부에 도메인 특화 언어`DSL, domain specific language`응 정의해서 확장할 수 있는 유연한 문법을 제공했다. C++도 연산자 오버로딩`Operator overloading`과 템플릿`template`시스템을 통해 적용하고 확장할 수 있는 또 다른 확장 가능한 언어다. 다만, 스칼라와 비교해보면 C++는 더 저 수준이고, 더 시스템 지향적인 핵심`core`언어를 사용한다.  
 스칼라는 함수형 프로그래밍과 객체지향 프로그래밍을 통합한 첫 번째 언어는 아니다. 다만, 아마도 그런 방향으로 가장 발전한 언어일 것이다. 함수형 프로그래밍의 요소 중 일부라도 OOP에 통합한 언어로는 루비, 스몰토크, 파이썬 등을 들 수 있다. 자바 플랫폼의 경우 피자`Pizza`, 나이스`Nice`, 멀티자바`Multi-Java`언어가 자바와 비슷한 핵심 언어를 함수형 아이디어로 확장했다. 또한 오캐멀, F#, PLT-스킴`PLT-Scheme`같이 함수형이 주인 언어에 객체 시스템을 통합한 것도 있다.  
 스칼라가 프로그래밍 언어 분야의 혁신에 기여한 부분도 있다. 예를 들어 스칼라의 추상 타입은 제네릭 타입보다 더 객체지향적인 대안이 될 수 있다. 스칼라 트레이트는 더 유연한 컴포넌트 조립을 허용하며, 익스트랙터`extractor`는 패턴 매치를 내부 표현과 분리하는 방법을 제공한다.
 
## 1.5 결론
 1장에서느 스칼라가 어떤 것이고 그 언어가 프로그래밍에 어떤 도움이 될지를 간략하게 살펴봤다. 분명한 건, 스칼라가 여러분을 더 생산적으로 만들어줄 수 있는 마법의 물약은 아니라는 점이다. 더 나아가기 위해서는 스칼라를 솜씨 좋게 적용할 필요가 있다. 그러기 위해서는 학습과 연습이 필요하다. 자바에서 넘어온 사람이 스칼라를 배우는 경우, 가장 힘든 분야는 아마도 스칼라의 타입 시스템(자바보다 훨씬 풍부하다)과 함수형 프로그래밍일 것이다. 이 책의 목적은 한번에 한 걸음씩 스칼라 학습 곡선에 부드럽게 올라타도록 돕는 데 있다. 스칼라 프로그래밍이 여러분의 지평을 넓히고 프로그램 설계 시 사고방식을 바꿀 수 있는 지적인 경험을 제공한다는 사실을 체감하리라 생각한다 또한 스칼라 프로그래밍을 통해 재미와 영감도 얻기 바란다.  
 다음 장에서는 직접 스칼라 코드를 작성해 볼 것이다.

## 소감
처음 md로 제대로 작성해 본 것이라, 책의 내용을 그대로 베끼는 것이 많았다. 이 책이 끝날 때 쯤이면 내용을 요약하는 능력이 길러져 있길 바래야지. 스칼라 자체의 내용은 대부분 아는 것이었지만, 타입 시스템은 그 개념이 나에게 없어서 내용을 이해하기가 힘들었다. 한주에 한 챕터씩 꼭꼭 요약해서 열심히 작성하자! 책이 끝날 때 쯤에는 스칼라를 이용한 딥러닝을 구현할 수 있으면 좋겠다.
