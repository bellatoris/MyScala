# Chapter1 Scalable Language

### 스칼라를 어떻게 배울 것인가?
* 책이 제공하는 다양한 프로그래밍 예제를 직접해보자.
* 예제를 여러가지로 변형해보는 것은 예제를 더 재미있게 만들고 각 동작을 제대로 이해 했는지 확인 할 수 있다.
* 책을 충분히 읽었다면 스스로 프로그래밍 프로젝트를 만들어 보자.
	* 작은 프로그램을 바닥부터 만들어보고, 더 큰 프로그램에 들어가는 애드인을 만들어보자.
* **책을 읽기만 해서는 그리 멀리 나아갈 수 없다.**

### 소스 코드 
이 책의 소스 코드가 담긴 ZIP 파일을 내려받을 수 있다.  
[Link1](http://booksites.artima.com/programming_in_scala_2ed)


# 1장 확장 가능한 언어
Scala 라는 이름은 Scalable Language 라는 뜻이다. 스칼라 사용자는 작은 스크립트를 작성하는 일부터, 커다란 시스템을 구축하는 일까지 광버위한 프로그래밍 과업에 스칼라를 활용할 수 있다. 기술적으로, 스칼라는 객체지향과 함수형 프로그래밍 개념을 정적 타입 언어에 합쳐 놓은 언어다. 마틴 오더스키에 의하면 객체지향 패러다임과 함수형 패러다임은 orthogonal 하기 떄문에 객체지향 + 명령형 프로그래밍도 가능하며 객체지향 + 함수형 프로그래밍도 가능한 것이다.  
스칼라는 널리 쓰이는 여타 언어들에 비해 더 광범위하다고 말할 수 있다. 규모 확장성 측면에서 두 프로그래밍 스타일에는 상호 보완적인 강점이 있다. 스칼라의 함수형 프로그래밍 구성요소를 사용하면 관심 대상을 간단한 부품으로부터 빠르고 쉽게 만들 수 있다. 스칼라의 객체지향 구성요소를 사용하면 더 큰 시스템을 구조화하고 새로운 요구에 맞춰 구조를 쉽게 변형할 수 있다.


## 1.1 점점 여러분의 마음에서 자라가는 언어
스칼라는 편리함과 유연성을 동시에 제공한다. 스칼라는 빠르게 익혀서 시작할 수 있고 즐겁게 간결한 스탈일로 프로그램할 수 있는 편리한 구성요소를 제공한다. 동시에, 스칼라는 여러분의 생각이 언어에 의해 제약받는 일이 없도록 보장한다. 

### 새로운 타입을 키워가기
성당은 완벽에 가까운 건물로 짓는 데 오랜 시간이 걸린다. 일단 다 건설하고 나면 성당은 오랫동안 그대로 남는다. 반면, 시장은 내부에서 일하는 사람들이 매일 상황에 맞게 변경하고 확장한다. 스칼라는 성당보다는 시장에 가까운 언어다. 이 언어를 사용하는 사람들이 확장하고 변경할 수 있도록 설계되어있다는 점에서 그렇다.

```scala
def factorial(x: BigInt): BigInt = 
	if (x == 0) 1 else x * factoial(x - 1)
```
`BigInt`는 내장 타입과 같아 보인다. 정수 리터럴이나  *, - 등의 연산자를 해당 타입의 값에 그대로 사용할 수 있기 때문이다. 하지만 이 클래스도 스칼라의 표준 라이브러리에 들어 있는 평범한 클래스일 뿐이다. (연산자들을 오버라이딩 할 수 있게 해놔서 위의 예제가 가능한 것이다.) 스칼라는 언어가 기본 지원하는 것처럼 느껴지는, 쉽게 사용할 수 있는 라이브러리를 통해 언어를 사용자가 필요한 방향으로 확장하고 고칠 수 있게 허용한다.

### 새로운 제어 구조 키워가기
스칼라는 확장성 원칙을 제어 구조에도 마찬가지로 적용한다. 이러한 확장성을 스칼라 API의 '액터 기반' 동시성 프로그래밍 API에서 볼 수 있다. 멀티 쓰레딩을 완벽하게 하는 것은 매우 어려운일이다. 특히나, 시스템의 크기와 복잡도가 증가할수록 더 그렇다. 안전한 대안은 Erlang 프로그래밍 언어에서 사용하는 '액터'같은 메시지 전달 아키텍쳐일 것이다.  
스칼라는 여타 자바 API와 마찬가지로 스레드 기반 동시성 라이브러리를 활용할 수 있다. 그러나 스칼라는 본질적으로 Erlang의 액터 모델을 구현하는 라이브러리를 추가로 제공한다.  
액터는 스레드 위에 구현할 수 있는 동시성 추상화 요소다. 액터들은 서로 메시지를 보냄으로써 통신한다. 액터가 수행할 수 있는 기본 연산은 메시지 송신과 수신이다. 송신 연산은 느낌표(!)로 표시하며, 메시지를 다른 액터에 보낸다. 다음은 `recipient`라는 액터에 메시지를 보내는 문장이다.

```scala
recipient ! msg
```
송신은 비동기적 `asynchronous`이다. 즉, 메시지를 보낸 액터는 수신자가 메시지를 수신할 때까지 기다릴 필요 없이 즉시 다음 작업을 진행할 수 있다는 뜻이다. 모든 액터에는 들어오는 메시지가 들어가 대기하는 **우편함**`mailbox`이 있다. 또한 액터는 우편함에 도착한 메시지를 `receive`블록을 사용해 처리한다.

```scala
recieve {
	case Msg1 => ... // Msg1을 처리함
	case Msg2 => ... // Msg2을 처리함
	// ...
}
```
`receive` 블록은 우편함의 메시지를 패턴에 따라 처리하는 여러 가지 `case`문장으로 이뤄져 있다. 우편함에 있는 메시지 중 `case`를 하나 만족하는 최초의 메시지를 선택해서, 그에 따른 동작을 수행한다. 주어진 여러 `case`를 만족하는 메시지가 우편함에 하나도 없다면, 액터는 동작을 멈추고 다음 메시지가 도착할 때까지 기다린다.  
  
 예를 들어 다음은 체크섬`checksum` 계산 서비스를 구현하는 스칼라 액터다.
 
```scala
actor {
 	var sum = 0
 	loop {
 		receive {
 			case Data(bytes) 		=> sum += hash(bytes)
 			case GetSum(requester) 	=> requester ! sum
		}
	}
}
```

이 액터의 맨 앞에는 0으로 초기화한 `sum`이라는 변수 선언이 있다. 그 다음에 이 액터는 `loop`와 `receive` 명령을 사용해 메시지를 
기다리는 일을 반복한다. `Data` 메시지를 받을 때마다 그 데이터(`bytes`)의 해시를 계산해 `sum` 변수에 더한다. `GetSum`메시지를 받으면, 요청한 `requestor`에게  `requestor ! sum`이라는 송신 명령을 사용해 현재 `sum`값을 전송한다. `requestor`필드는 `GetSum`메시지 안에 들어 있으며, 보통은 요청을 보냈던 액터를 나타낼 것이다.  
이 예에서 중요한 내용은, 확장성이라는 측면에서 볼 때  `actor`나 `loop`, `receive`, 메시지, 메시지 송신(!) 등이 모두 다 스칼라 내장 기능이 아니라는 점에 있다, `actor`, `loop`, `receive`는 모두 `while`이나 `for`루프처럼 스칼라 내장 구성요소인 것처럼 보인다. 하지만 실제로 이들에 대한 정의는 스칼라 내장 구성요소인 것처럼 보인다. 하지만 실제로 이들에 대한 정의는 스칼라의 액터 라이브러리에 들어 있다. 마찬가지로, '!'가 내장 연산자인 것처럼 보이지만 그 역시도 액터 라이브러리에서 정의한 연산자다. 이 네 가지 (액터) 구성요소는 모두 스칼라 프로그래밍 언어와는 완전히 별개다.  
스칼라의 `receive`블록이나 송신(!) 문법은 Erlang과 매우 비슷하다. 하지만 Erlang은 이런 요소를 언어에 내장해 제공한다. 스칼라는 Erlang이 제공하는 그 밖의 동시성 프로그래밍 구성요소도 구현해 제공한다. 예를 들어 실패한 액터를 모니터링하는 기능이나, 타임아웃 등을 구현한다. 대체로 액터는 동시적인 분산 컴퓨팅을 표현하기에 아주 쾌적한 도구임이 드러났다. 라이브러리임에도 불구하고, 액터는 스칼라 언어와 완전히 하나인 것처럼 보인다.  
이 예제는 스칼라 언어를 동시성 프로그래밍과 같이 특별한 분야로까지 '키울'수 있음을 보여준다. 물론 이를 위해서는 훌륭한 아키텍트와 프로그래머가 설계해야 하겠지만, 그런 일이 가능하다는 사실 자체가 중요하다. 즉, 전혀 새로운 애플리케이션 분야를 처리하는 추상화를 스칼라에서 설계하고 구현할 수 있으며, 그럼에도 마치 언어가 원래부터 지원하는 것처럼 느끼게 할 수 있다.

## 1.2 스칼라의 확장성이 가능한 이유